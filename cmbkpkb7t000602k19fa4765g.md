---
title: "ğŸ“…Week-4 (Day -4) - Learn to Design a File System with Composite Pattern: Complete UML and Coding Tutorial"
seoTitle: "Composite Pattern File System Design"
seoDescription: "Learn to design a file system using the Composite Pattern with this complete tutorial on UML diagrams and coding, ideal for system design beginners"
datePublished: Fri Jun 06 2025 11:14:37 GMT+0000 (Coordinated Universal Time)
cuid: cmbkpkb7t000602k19fa4765g
slug: week-4-day-4-learn-to-design-a-file-system-with-composite-pattern-complete-uml-and-coding-tutorial
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1749205285295/9dc77a5d-58d7-45d3-94cc-b4ee55b02456.png
ogImage: https://cdn.hashnode.com/res/hashnode/image/upload/v1749208310454/e93c1957-9696-467a-8c8e-3bd419a0a9b1.png
tags: cpp, code, blogging, java, technology, coding, dsa, techblog, coding-challenge, technical-writing-1, coding-journey, low-level-design, lld, coderarmy, payalkumari11

---

> ***NOTE: - <mark>I started my 8-week system design journey with Coder Army. I will be journaling every day, recording what I learn, reflecting on it, and sharing it with my network to help newcomers to system design.</mark>***

---

## ğŸ’  What is the Composite Design Pattern?

> **"The Composite Pattern lets us treat individual objects and groups of objects uniformly. This means whether it's a single file ğŸ“„ or a folder ğŸ“ containing many files â€” we handle them the same way."**

"It allows you to compose objects into tree structures to represent **part-whole hierarchies**. This means both **individual objects (like files ğŸ“„)** and **composite groups (like folders ğŸ“)** can be treated uniformly through a **common interface**.

(Hindi: "Composite Pattern aise design pattern ko kehte hain jo part-whole structure create karta hai, jismein file aur folder ko ek jaise interface ke through access kiya ja sakta hai â€” chahe wo ek file ho ya ek folder jismein 100 files hoon.")

## ğŸ’  Real-Life Analogy: File Explorer in Your PC ğŸ–¥ï¸

Imagine:

* A **file** = a single document like "Resume.pdf"
    
* A **folder** = a directory with 10 files inside
    
* When you right-click and get options like open, delete, size â€” you can do the same with both, right?
    

â¡ï¸ That's Composite Pattern in action â€” uniform treatment for both simple and complex components.

## ğŸ’  UML Class Diagram Breakdown

To build our file system, we use 3 main classes:

### 1ï¸âƒ£ **Component (Interface)**

Defines the common methods for all elements â€” like `open()`, `getSize()`, `display()`.

### 2ï¸âƒ£ **File (Leaf Node)**

Represents individual files. Implements methods like:

* `getSize()` â†’ returns its own size
    
* `display()` â†’ prints file name
    

### 3ï¸âƒ£ **Folder (Composite Node)**

Can hold multiple files or other folders. Implements methods like:

* `add(Component)`
    
* `remove(Component)`
    
* `getSize()` â†’ adds up size of all children
    

(Hindi: Folder ek aisi entity hai jisme aur bhi folders ya files ho sakti hain. File sirf apne size ka dhyan rakhti hai, lekin Folder sabke size ka calculation karta hai.)

## ğŸ’ Example UML Design

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1749207741349/f0d129e0-5895-4529-8698-1e2ac82cfdf1.png align="center")

## ğŸ’ Standard UML Design

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1749208145956/7ce2b962-a783-4978-a6ea-24cca946ffae.png align="center")

## ğŸ’ Code

```java
import java.util.ArrayList;
import java.util.List;

// Base interface for files and folders
interface FileSystemItem {
    void ls(int indent);            
    void openAll(int indent);      
    int getSize();                  
    FileSystemItem cd(String name); 
    String getName();
    boolean isFolder();
}

// Leaf: File
class File implements FileSystemItem {
    private String name;
    private int size;

    public File(String n, int s) {
        name = n;
        size = s;
    }

    @Override
    public void ls(int indent) {
        String indentSpaces = " ".repeat(indent);
        System.out.println(indentSpaces + name);
    }

    @Override
    public void openAll(int indent) {
        String indentSpaces = " ".repeat(indent);
        System.out.println(indentSpaces + name);
    }

    @Override
    public int getSize() {
        return size;
    }

    @Override
    public FileSystemItem cd(String name) {
        return null;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public boolean isFolder() {
        return false;
    }
}

class Folder implements FileSystemItem {
    private String name;
    private List<FileSystemItem> children;

    public Folder(String n) {
        name = n;
        children = new ArrayList<>();
    }

    public void add(FileSystemItem item) {
        children.add(item);
    }

    @Override
    public void ls(int indent) {
        String indentSpaces = " ".repeat(indent);
        for (FileSystemItem child : children) {
            if (child.isFolder()) {
                System.out.println(indentSpaces + "+ " + child.getName());
            } else {
                System.out.println(indentSpaces + child.getName());
            }
        }
    }

    @Override
    public void openAll(int indent) {
        String indentSpaces = " ".repeat(indent);
        System.out.println(indentSpaces + "+ " + name);
        for (FileSystemItem child : children) {
            child.openAll(indent + 4);
        }
    }

    @Override
    public int getSize() {
        int total = 0;
        for (FileSystemItem child : children) {
            total += child.getSize();
        }
        return total;
    }

    @Override
    public FileSystemItem cd(String target) {
        for (FileSystemItem child : children) {
            if (child.isFolder() && child.getName().equals(target)) {
                return child;
            }
        }
        // not found or not a folder
        return null;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public boolean isFolder() {
        return true;
    }
}

public class CompositePattern {
    public static void main(String[] args) {
        // Build file system
        Folder root = new Folder("root");
        root.add(new File("file1.txt", 1));
        root.add(new File("file2.txt", 1));

        Folder docs = new Folder("docs");
        docs.add(new File("resume.pdf", 1));
        docs.add(new File("notes.txt", 1));
        root.add(docs);

        Folder images = new Folder("images");
        images.add(new File("photo.jpg", 1));
        root.add(images);

        root.ls(0);

        docs.ls(0);

        root.openAll(0);

        FileSystemItem cwd = root.cd("docs");
        if (cwd != null) {
            cwd.ls(0);
        } else {
            System.out.println("\nCould not cd into docs\n");
        }

        System.out.println(root.getSize());
    }
}
```

## ğŸ’ Why Use Composite Pattern? (Easy Points + Hinglish)

* **Consistency**: Treat folders and files alike (Sabko ek hi nazar se dekhna â€” chahe file ho ya folder)
    
* **Scalability**: Easily add more levels of folders inside folders
    
* **Flexibility**: Add/remove components at runtime
    
* **Encapsulation**: Folders hide internal complexity of child files
    

## ğŸ’ Sample Use Case: Recursive Folder Scanner

You can now:

* List all files in a folder
    
* Calculate total size (folder + its content)
    
* Search deeply nested items â€” like how File Explorer shows nested subfolders
    

(Hindi: Jaise aap apne laptop me kisi folder ka total size dekhte ho â€” wahi kaam yeh pattern allow karta hai, bina har baar manual calculation ke.)

## ğŸ’ Best Practices (Easy for Beginners Too!)

* Use **interfaces** or **abstract classes** for common actions
    
* Avoid putting too much logic inside one class â€” let files and folders manage themselves
    
* Recursion is your best friend for nested structures
    

## ğŸ’ Recap in Simple Style

* Composite Pattern allows:
    

> Ek jaisa interface for files and folders

* Folders can hold files or other folders:
    

> Aur har ek ko handle karna easy hota hai â€” chahe woh single file ho ya 10 layers of subfolders.

* Learn once, apply everywhere:
    

> Operating systems, image editors, graphic UI systems â€” sab mein yeh use hota hai.

(Hindi: Jaise apne room me sab saman ko sahi jagah rakhte ho, waise hi Composite pattern sabko sahi tarike se structure karta hai.)

### **Week - 4 (Day-4) Completed âœ… System Design**

> ***NOTE : - A big thanks to my mentors <mark>Rohit Negi</mark> <mark>Sir </mark> and*** [***<mark>Aditya</mark>***](https://www.linkedin.com/in/adityatandon2/) [***<mark>Sir</mark> fo***](https://www.linkedin.com/in/adityatandon2/)***r launching this amazing <mark>8-week course</mark> absolutely <mark>free</mark> on YouTube via <mark>CoderArmy9 </mark> :-*** [***youtube.com/@CoderArmy9***](http://youtube.com/@CoderArmy9) [***. ğŸ™Œ***](https://www.youtube.com/@CoderArmy9)

ğŸ‘‰ **Share this blog with your connections!** Letâ€™s keep learning, growing, and supporting one another on this journey. ğŸš€

âœï¸ [***Payal Kumari***](https://www.linkedin.com/in/payalkumari10/) ğŸ‘©â€ğŸ’»

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1749208230132/1270a96f-c1f3-4b31-b87a-66e6819d7024.jpeg align="center")

  
**Jai Hind ğŸ‡®ğŸ‡³ | #CoderArmy #LearningInPublic #SystemDesign #TechForAll #MentorshipMatters** [**#8weeksLLdChallenge**](https://www.youtube.com/hashtag/8weekslldchallenge) [**#LowLevelDesign** **#Code #LLD**](https://www.youtube.com/hashtag/8weekslldchallenge) [**#OOP**](https://www.youtube.com/hashtag/lowleveldesign) [**ğŸ‘©â€ï¿½**](https://www.youtube.com/hashtag/lld)[**ï¿½**](https://www.youtube.com/hashtag/lowleveldesign)

%[https://youtu.be/xaaiMGmyDJk?si=0gtagFv_zPRADRSS]